package com.api.framework.testing.swagger;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.PathItem;
import io.swagger.v3.oas.models.media.Schema;
import io.swagger.v3.oas.models.parameters.Parameter;
import io.swagger.v3.oas.models.parameters.RequestBody;
import io.swagger.v3.parser.OpenAPIV3Parser;
import io.swagger.v3.parser.core.models.SwaggerParseResult;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.io.File;
import java.util.*;

@Service
public class ScenarioGenerator {

    @Value("${swagger.url}")
    private String swaggerUrl;

    @Value("${app.url}")
    private String applicationUrl;

    private final ObjectMapper mapper = new ObjectMapper();

    public Map<String, Object> generate() throws Exception {
        SwaggerParseResult parseResult = new OpenAPIV3Parser().readLocation(swaggerUrl, null, null);
        OpenAPI openAPI = parseResult.getOpenAPI();

        Map<String, List<Map<String, Object>>> tagToTestCases = new HashMap<>();

        openAPI.getPaths().forEach((path, pathItem) -> {
            Map<PathItem.HttpMethod, io.swagger.v3.oas.models.Operation> operations = pathItem.readOperationsMap();

            for (Map.Entry<PathItem.HttpMethod, io.swagger.v3.oas.models.Operation> entry : operations.entrySet()) {
                PathItem.HttpMethod method = entry.getKey();
                io.swagger.v3.oas.models.Operation operation = entry.getValue();

                String tag = operation.getTags() != null && !operation.getTags().isEmpty()
                        ? operation.getTags().get(0)
                        : "default";

                Schema<?> schema = null;
                Map<String, Object> requestBody = new HashMap<>();

                if (operation.getRequestBody() != null) {
                    schema = extractSchema(operation.getRequestBody(), openAPI);
                    if (schema != null) {
                        requestBody = generateSampleRequest(schema, openAPI);
                    }
                }

                Map<String, String> queryParams = new HashMap<>();
                Map<String, String> headers = new HashMap<>();
                String endpointPath = path;

                if (operation.getParameters() != null) {
                    for (Parameter param : operation.getParameters()) {
                        String name = param.getName();
                        String exampleValue = "sample_" + name;

                        switch (param.getIn()) {
                            case "path" -> endpointPath = endpointPath.replace("{" + name + "}", exampleValue);
                            case "query" -> queryParams.put(name, exampleValue);
                            case "header" -> headers.put(name, exampleValue);
                        }
                    }
                }

                String fullEndpoint = endpointPath;
                if (!queryParams.isEmpty()) {
                    StringJoiner sj = new StringJoiner("&");
                    queryParams.forEach((k, v) -> sj.add(k + "=" + v));
                    fullEndpoint += "?" + sj;
                }

                List<Map<String, Object>> testCases = new ArrayList<>();

                Map<String, Object> positiveScenario = new HashMap<>();
                positiveScenario.put("name", Optional.ofNullable(operation.getSummary()).orElse("AutoGenerated Test"));
                positiveScenario.put("description", Optional.ofNullable(operation.getDescription()).orElse("Generated from Swagger"));
                positiveScenario.put("datasets", List.of(Map.of(
                        "request_body", requestBody,
                        "desired_status", getSuccessStatusCode(operation),
                        "desired_outcome", serializeJson(requestBody)
                )));

                Map<String, Object> positiveTestCase = new HashMap<>();
                positiveTestCase.put("baseUrl", applicationUrl);
                positiveTestCase.put("endpoint", fullEndpoint.replaceFirst("^/", ""));
                positiveTestCase.put("mappingType", method.name());
                headers.putIfAbsent("content-Type", "application/json"); // ensure default is set
                positiveTestCase.put("header", headers);
                positiveTestCase.put("scenario", positiveScenario);

                testCases.add(positiveTestCase);

                if (schema != null) {
                    List<Map<String, Object>> negativeDatasets = generateNegativeTestCases(schema, requestBody, openAPI);
                    for (Map<String, Object> negativeDataset : negativeDatasets) {
                        Map<String, Object> negativeScenario = new HashMap<>();
                        negativeScenario.put("name", Optional.ofNullable(operation.getSummary()).orElse("AutoGenerated Test"));
                        negativeScenario.put("description", Optional.ofNullable(operation.getDescription()).orElse("Generated from Swagger"));
                        negativeScenario.put("datasets", List.of(negativeDataset));

                        Map<String, Object> negativeTestCase = new HashMap<>();
                        negativeTestCase.put("baseUrl", applicationUrl);
                        negativeTestCase.put("endpoint", fullEndpoint.replaceFirst("^/", ""));
                        negativeTestCase.put("mappingType", method.name());
                        headers.putIfAbsent("content-Type", "application/json"); // ensure default is set
                        negativeTestCase.put("header", headers);
                        negativeTestCase.put("scenario", negativeScenario);

                        testCases.add(negativeTestCase);
                    }
                }

                tagToTestCases.computeIfAbsent(tag, k -> new ArrayList<>()).addAll(testCases);
            }
        });

        ObjectMapper mapper = new ObjectMapper();
        for (Map.Entry<String, List<Map<String, Object>>> entry : tagToTestCases.entrySet()) {
            Map<String, Object> finalMap = new HashMap<>();
            finalMap.put("report", null);
            finalMap.put("data_list", entry.getValue());

            String fileName = "generated-testcases-" + entry.getKey().toLowerCase().replaceAll("\\s+", "_") + ".json";
            mapper.writeValue(new File(fileName), finalMap);
            System.out.println("✅ Generated file: " + fileName);
        }

        return Map.of("status", "success", "filesGenerated", tagToTestCases.keySet());
    }

    private String serializeJson(Map<String, Object> data) {
        try {
            return new ObjectMapper().writeValueAsString(data);
        } catch (JsonProcessingException e) {
            return "{}";
        }
    }

    private String getSuccessStatusCode(io.swagger.v3.oas.models.Operation operation) {
        return operation.getResponses().keySet().stream()
                .filter(code -> code.matches("\\d{3}") && code.startsWith("2"))
                .findFirst()
                .orElse("200");
    }

    private Schema<?> extractSchema(RequestBody requestBody, OpenAPI openAPI) {
        if (requestBody.getContent() != null &&
                requestBody.getContent().get("application/json") != null &&
                requestBody.getContent().get("application/json").getSchema() != null) {
            Schema<?> schema = requestBody.getContent().get("application/json").getSchema();
            if (schema.get$ref() != null) {
                String refName = schema.get$ref().replace("#/components/schemas/", "");
                return openAPI.getComponents().getSchemas().get(refName);
            }
            return schema;
        }
        return null;
    }

    private Map<String, Object> generateSampleRequest(Schema<?> schema, OpenAPI openAPI) {
        Map<String, Object> sample = new HashMap<>();
        schema = resolveSchema(schema, openAPI);
        // ✅ Use object-level example if present
        if (schema.getExample() != null) {
            try {
                return mapper.convertValue(schema.getExample(), new TypeReference<Map<String, Object>>() {});
            } catch (IllegalArgumentException e) {
                System.err.println("⚠️ Failed to convert example to Map: " + e.getMessage());
                // fallback to property generation
            }
        }

        if (schema.getProperties() != null) {
            schema.getProperties().forEach((key, value) -> {
                Schema<?> prop = resolveSchema((Schema<?>) value, openAPI);
                Object val = generateValueForSchema(prop, openAPI);
                sample.put(key, val);
            });
        }

        return sample;
    }

    // generateValueForSchema
    private Object generateValueForSchema(Schema<?> schema, OpenAPI openAPI) {
        schema = resolveSchema(schema, openAPI);
        if (schema == null) return "unknown";

        // ✅ Prefer example
        if (schema.getExample() != null) return schema.getExample();

        // ✅ Enum fallback
        if (schema.getEnum() != null && !schema.getEnum().isEmpty()) return schema.getEnum().get(0);

        // ✅ Type resolution
        String type = schema.getType();
        if (type == null) {
            // Guess fallback type
            if (schema.getProperties() != null) {
                return generateSampleRequest(schema, openAPI);
            } else if (schema.getItems() != null) {
                Schema<?> itemSchema = resolveSchema(schema.getItems(), openAPI);
                Object item = generateValueForSchema(itemSchema, openAPI);
                return List.of(item);
            } else {
                return "unknown";
            }
        }

        return switch (type) {
            case "string" -> "sample_string";
            case "integer" -> 123;
            case "boolean" -> true;
            case "number" -> 99.99;
            case "object" -> generateSampleRequest(schema, openAPI);
            case "array" -> {
                Schema<?> itemSchema = schema.getItems();
                itemSchema = resolveSchema(itemSchema, openAPI);
                Object item = generateValueForSchema(itemSchema, openAPI);
                yield List.of(item);
            }
            default -> "unknown";
        };
    }

    private Schema<?> resolveSchema(Schema<?> schema, OpenAPI openAPI) {
        Set<String> visitedRefs = new HashSet<>();
        return resolveSchemaRecursive(schema, openAPI, visitedRefs);
    }

    private Schema<?> resolveSchemaRecursive(Schema<?> schema, OpenAPI openAPI, Set<String> visitedRefs) {
        if (schema == null) return null;
        if (schema.getAnyOf() != null && !schema.getAnyOf().isEmpty()) {
            schema = (Schema<?>) schema.getAnyOf().get(0);
        } else if (schema.getOneOf() != null && !schema.getOneOf().isEmpty()) {
            schema = (Schema<?>) schema.getOneOf().get(0);
        } else if (schema.getAllOf() != null && !schema.getAllOf().isEmpty()) {
            schema = (Schema<?>) schema.getAllOf().get(0);
        }

        while (true) {
            // Handle $ref
            if (schema.get$ref() != null) {
                String refName = schema.get$ref().replace("#/components/schemas/", "");
                if (visitedRefs.contains(refName)) return schema; // prevent circular refs
                visitedRefs.add(refName);
                schema = openAPI.getComponents().getSchemas().get(refName);
                if (schema == null) return null;
                continue;
            }

            // Handle anyOf
            if (schema.getAnyOf() != null && !schema.getAnyOf().isEmpty()) {
                schema = resolveSchemaRecursive((Schema<?>) schema.getAnyOf().get(0), openAPI, visitedRefs);
                continue;
            }

            // Handle oneOf
            if (schema.getOneOf() != null && !schema.getOneOf().isEmpty()) {
                schema = resolveSchemaRecursive((Schema<?>) schema.getOneOf().get(0), openAPI, visitedRefs);
                continue;
            }

            // Handle allOf
            if (schema.getAllOf() != null && !schema.getAllOf().isEmpty()) {
                schema = resolveSchemaRecursive((Schema<?>) schema.getAllOf().get(0), openAPI, visitedRefs);
                continue;
            }

            break;
        }

        return schema;
    }

    private List<Map<String, Object>> generateNegativeTestCases(
            Schema<?> schema, Map<String, Object> originalRequest, OpenAPI openAPI) {

        List<Map<String, Object>> negativeCases = new ArrayList<>();

        if (schema.get$ref() != null) {
            String refName = schema.get$ref().replace("#/components/schemas/", "");
            schema = openAPI.getComponents().getSchemas().get(refName);
        }

        if (schema.getRequired() != null) {
            for (String requiredField : schema.getRequired()) {
                Map<String, Object> copy = new HashMap<>(originalRequest);
                copy.remove(requiredField);

                Map<String, Object> testCase = new HashMap<>();
                testCase.put("request_body", copy);
                testCase.put("desired_status", "400");
                testCase.put("desired_outcome", "{\"error\": \"Missing field: " + requiredField + "\"}");

                negativeCases.add(testCase);
            }
        }

        return negativeCases;
    }
}
